---
title: "Plots SW GA"
output: word_document
---

```{r , echo=F, warning = F, message = F, fig.keep='all'}
# A good place to find documentation and descriptions on this model 
# http://2019-coronavirus-tracker.com/stochastic-model.html
# The Georgia simulations are posted here
# http://2019-coronavirus-tracker.com/stochastic-GA.html
library(dplyr)
library(magrittr)
library(readr)
library(tidyr)
library(lubridate)
library(ggplot2)

### Modelling the Epidemic -----------------------------------------------------

# The function onestep simulates one time step in the transmission process.
# Called by the function model()
onestep <- function (x, params) {
  
  S <- x[2]                            #local variable for susceptibles
  
  E1 <- x[3]                           #exposed classes
  E2 <- x[4]
  E3 <- x[5]
  E4 <- x[6]
  E5 <- x[7]
  E6 <- x[8]
  
  I1 <- x[9]                           #detected infectious classes
  I2 <- x[10]
  I3 <- x[11]
  I4 <- x[12]
  
  Iu1 <- x[13]                           #undetected infectious classes
  Iu2 <- x[14]
  Iu3 <- x[15]
  Iu4 <- x[16]
  
  I.detected <-I1+I2+I3+I4
  I.undetected <- Iu1+Iu2+Iu3+Iu4
  I <- I1+I2+I3+I4+Iu1+Iu2+Iu3+Iu4     #total infectious
  
  H <- x[17]                           #local variable for Isolated
  Ru <- x[18]                          #local variable for undetected recovereds
  
  C <- x[19]    # local variable for notifications
  
  N <- S+E1+E2+E3+E4+E5+E6+I1+I2+I3+I4+Iu1+Iu2+Iu3+Iu4+H+Ru          # total size of population
  
  t <- x[20]                          #get current time
  
  with(                                #use with to simplify code
    as.list(params), 
    {
      gammai <- 4*gamma(z=z, b=b, a0=a0, t=as.numeric(t))  # multiplier 4 for pseudo stages
      sigmai <- 6*sigma  # multiplier 6 for pseudo stages
      etat <- eta(t,w)     # case notification rate
      betat <- beta(t,w)   # time dependent transmissibility, presymptomatic=1 causes this transmissibility to apply to late stage latent cases as well
      
      rates <- as.numeric(c(betat*I.detected/N+betat*c*I.undetected/N+presymptomatic*betat*c*E6/N,                           # movements out of S
                            sigmai, sigmai, sigmai, sigmai, sigmai, sigmai,   # movements out of E
                            gammai, gammai, gammai, gammai,                   # movements out of I (detected)
                            b, b, b, b,                                       # movements out of I (undetected)
                            etat))
      
      states0 <- x[2:(length(x)-1)]
      
      # transition probabilities
      
      p <- matrix(0, nrow=length(rates),ncol=length(states0))                                     # matrix to hold transitions probs
      
      p[1,]  <- c(exp(-rates[1]*dt),1-exp(-rates[1]*dt), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)   # S-> E
      
      p[2,]  <- c(0, exp(-rates[2]*dt), 1-exp(-rates[2]*dt), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)    # Transitions out of E
      p[3,]  <- c(0, 0, exp(-rates[3]*dt), 1-exp(-rates[3]*dt), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)    # Transitions out of E
      p[4,]  <- c(0, 0, 0, exp(-rates[4]*dt), 1-exp(-rates[4]*dt), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)    # Transitions out of E
      p[5,]  <- c(0, 0, 0, 0, exp(-rates[5]*dt), 1-exp(-rates[5]*dt), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)    # Transitions out of E
      p[6,]  <- c(0, 0, 0, 0, 0, exp(-rates[6]*dt), 1-exp(-rates[6]*dt), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)    # Transitions out of E
      p[7,]  <- c(0, 0, 0, 0, 0, 0, exp(-rates[7]*dt), (1-exp(-rates[7]*dt))*q(w), 0, 0, 0, (1-exp(-rates[7]*dt))*(1-q(w)), 0, 0, 0, 0, 0, 0)    # Transitions out of E
      
      p[8,]  <- c(0, 0, 0, 0, 0, 0, 0, exp(-rates[8]*dt), 1-exp(-rates[8]*dt), 0, 0, 0, 0, 0, 0, 0, 0, 0)    # Transitions out of I (detected)
      p[9,]  <- c(0, 0, 0, 0, 0, 0, 0, 0, exp(-rates[9]*dt), 1-exp(-rates[9]*dt), 0, 0, 0, 0, 0, 0, 0, 0)    # Transitions out of I
      p[10,] <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, exp(-rates[10]*dt), 1-exp(-rates[10]*dt), 0, 0, 0, 0, 0, 0, 0)  # Transitions out of I
      p[11,] <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, exp(-rates[11]*dt), 0, 0, 0, 0, 1-exp(-rates[11]*dt), 0, 0)  # Transitions out of I -> H
      
      p[12,]  <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  exp(-rates[12]*dt), 1-exp(-rates[12]*dt), 0, 0, 0, 0, 0)    # Transitions out of I (undetected)
      p[13,]  <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  exp(-rates[13]*dt), 1-exp(-rates[13]*dt), 0, 0, 0, 0)    # Transitions out of I
      p[14,] <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  exp(-rates[14]*dt), 1-exp(-rates[14]*dt), 0, 0, 0)  # Transitions out of I
      p[15,] <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  exp(-rates[15]*dt), 0, 1-exp(-rates[15]*dt), 0)  # Transitions out of I -> R_u
      
      
      p[16,] <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, exp(-rates[16]*dt), 0, 1-exp(-rates[16]*dt))  # Transitions R_d -> to C (notification)
      
      # update states
      
      states1 <- matrix(0, nrow=length(rates),ncol=length(states0))                                # matrix to hold future states
      
      for(i in 1:length(rates)){
        states1[i,] <- t(rmultinom(1, states0[i], p[i,])) 
      }
      
      states1 <- colSums(states1)
      states1[17] <- states1[17]+Ru  #add formerly Recovered undetected cases
      states1[18] <- states1[18]+C  #add formerly notified cases
      
      return(x <- c(dt, states1, tail(x,1)+dt))
    }
  )
}

# The function model iteratively applies onestep to generate a solution of the 
# stochastic model.
# Called by the function evaluate.model()
model <- function (x, params, nstep) {  #function to simulate stochastic SIR
  output <- array(dim=c(nstep+1,length(x)))         #set up array to store results

  colnames(output) <- c("time","S",
                        "E1", "E2", "E3", "E4", "E5", "E6",
                        "I1", "I2", "I3", "I4", "Iu1", "Iu2", "Iu3", "Iu4",
                        "H", "Ru", "C", "cum.time") #name variables
  output[1,] <- x                           #first record of output is initial condition
  for (k in 1:nstep) {                      #iterate for nstep steps
    output[k+1,] <- x <- as.numeric(onestep(x,params))
  }
  output                                    #return output
}

# The function evaluate.model simulates an arbitrary number of realizations and 
# returns the result.
# Outermost call of model, calls model() which calls onestep()
evaluate.model <- function(params=list(beta0=0.6584, sigma=1/6.4, z=12, b=0.143, a0=1/1.5, w=12, c=1, presymptomatic=1, dt=0.05),
                           init = list(S=651461, E1=0, E2=0, E3=0, E4=0, E5=6, E6=0,
                                       I1 = 1, I2= 0, I3=0, I4=0, Iu1=0, Iu2=0, Iu3=0, Iu4=0,
                                       H=0, Ru=0, C=0),
                           nsims=2, nstep=NULL, start=as.Date("2020-03-14"),today=Sys.Date()){

  #run simulation from start to current time plus four weeks
  forward_days <- 42
  if(is.null(nstep)) nstep <- (as.numeric(today - start) + 1 + forward_days) / 
      params$dt 
  
  xstart <- c(time=0, unlist(init), cum.time = 0) #initial conditions
  
  data <- vector(mode='list',length=nsims) #initialize list to store the output
  
  for (k in 1:nsims) {              #simulate nsims times
    data[[k]] <- as.data.frame(model(xstart,params,nstep))
    data[[k]]$cum.time <- cumsum(data[[k]]$time)
    
  }
  
  # Add metadata to the simulation output
  attr(data, "nsims") <- nsims
  attr(data, "start_date") <- start
  attr(data, "nstep") <- nstep
  attr(data, "dt") <- params$dt
  attr(data, "forward_days") <- forward_days
  attr(data, "params") <- params
  attr(data, "init") <- init
  attr(data, "ndays") <- as.numeric(today - start) + 1 + forward_days
  return(data)
}

# The function plot.model provides automated visualization of model simulations.
# Part of the function includes the real count data to include with the model
# I don't currently have that file so I commented that part out to make this work
plot.model <- function(data, log='y', title=''){
  # The function `plot.model` provides automated visualization of model simulations
  
  # process data
  nsims <- length(data)
  
  for(i in 1:nsims) data[[i]]$I <- data[[i]]$I1 + data[[i]]$I2 + data[[i]]$I3 +
      data[[i]]$I4
  for(i in 1:nsims) data[[i]]$Iu <- data[[i]]$Iu1 + data[[i]]$Iu2 + data[[i]]$Iu3 +
      data[[i]]$Iu4
  for(i in 1:nsims) data[[i]]$E <- data[[i]]$E1 + data[[i]]$E2 + data[[i]]$E3 +
      data[[i]]$E4 + data[[i]]$E5 + data[[i]]$E6
  
  max.time<-data[[1]]$cum.time[max(which(data[[1]]$I>0))] #maximum time in first simulation
  max.y<-max(data[[1]]$C)       #find max total confirmed cases for plotting range
  
  # calculate means
  m1 <- m2 <- m3 <- m4 <- m5 <- matrix(nrow=length(data[[1]]$I), ncol=nsims)
  for(i in 1:nsims){
    m1[,i] <- data[[i]]$E
    m2[,i] <- data[[i]]$I+data[[i]]$Iu
    # m3[,i] <- data[[i]]$Iu
    m4[,i] <- data[[i]]$H
    m5[,i] <- data[[i]]$C
  }
  E.mean <- rowMeans(m1)
  I.mean <- rowMeans(m2)
  # Iu.mean <- rowMeans(m3)
  H.mean <- rowMeans(m4)
  C.mean <- rowMeans(m5)
  
  # colors
  col.E.ci <- rgb(0,1,0,.25)
  col.I.ci <- rgb(1,0,0,.25)
  Iu.col <- rgb(0.5, 0.5, 0, 0.25)
  col.nowcast.ci <- rgb(0,0,1,.25)
  col.cases.ci <- rgb(0,0,0,.25)
  col.E <- rgb(0,1,0,1)
  col.I <- rgb(1,0,0,1)
  Iu.mean.col <- rgb(0.5,0.5,0,1)
  col.nowcast <- rgb(0,0,1,1)
  col.cases <- rgb(0,0,0,1)
  
  #set up plot
  plot(I~cum.time,data=data[[1]],xlab='',ylab='Cases',col=1,
       xlim=c(0,max.time),ylim=c(1,max.y), type='n', lty=1, log=log,
       axes=FALSE, main=title, cex.main=0.8) # set up plot
  
  # add data to plot
  # day <- georgia$date - start
  # lines(day, cumsum(georgia$cases), type='h', col=col.cases, lwd=3, lend='butt' )
  
  # plot spaghetti
  lines(E~cum.time,data=data[[1]], col=col.E.ci, lty=1)
  lines(I+Iu~cum.time,data=data[[1]], col=col.I.ci, lty=1)
  # lines(Iu~cum.time,data=data[[1]], col=Iu.col, lty=1)
  lines(H~cum.time,data=data[[1]], col=col.nowcast.ci, lty=1)
  lines(C~cum.time,data=data[[1]], col=col.cases.ci, lty=1, lwd=1)
  
  
  axis(1, at=seq(0,max.time,5), labels=format(start+seq(0,max.time,5), format= '%b %d'))
  axis(2)
  box()
  
  if(nsims > 1){
    for (k in 2:min(100,nsims)) {              #add multiple epidemics to plot
      lines(E~cum.time, data=data[[k]], col=col.E.ci, type='l', lty=1)
      lines(I+Iu~cum.time, data=data[[k]], col=col.I.ci, type='l', lty=1)
      #   lines(Iu~cum.time, data=data[[k]], col=Iu.col, type='l', lty=1)
      lines(H~cum.time, data=data[[k]], col=col.nowcast.ci, type='l', lty=1)
      lines(C~cum.time, data=data[[k]], col=col.cases.ci, type='l', lty=1, lwd=1)
    }
    
    # plot means
    lines(E.mean~cum.time, data=data[[k]], col=col.E, lty=1)
    lines(I.mean~cum.time, data=data[[k]], col=col.I, lty=1)  
    #  lines(Iu.mean~cum.time, data=data[[k]], col=Iu.mean.col, lty=1)
    lines(H.mean~cum.time, data=data[[k]], col=col.nowcast, lty=1)
    lines(C.mean~cum.time, data=data[[k]], col=col.cases, lty=1)
  } 
  
  legend('topleft', lty=c(1,1,1,1,1,1), lwd=c(1,1,1,1,3,3), bty='n', cex=0.75,
         col=c(col.E, col.I, col.nowcast, col.cases, 'black'),
         legend=c('Latent cases in the community', 'Infectious cases in the community', 'Isolated', 
                  'Cumulative reported cases (Model)', 'Cumulative reported cases (Data)'))
}

plot.model.acc.old <- function(data, accdata.date, accdata.cases, log='y', 
                               title='', max.y = NA){
  # The function `plot.model` provides automated visualization of model simulations
  # ACC specific in terms of real data
  # process data
  nsims <- length(data)
  
  for(i in 1:nsims) data[[i]]$I <- data[[i]]$I1 + data[[i]]$I2 + data[[i]]$I3 +
      data[[i]]$I4
  for(i in 1:nsims) data[[i]]$Iu <- data[[i]]$Iu1 + data[[i]]$Iu2 + data[[i]]$Iu3 +
      data[[i]]$Iu4
  for(i in 1:nsims) data[[i]]$E <- data[[i]]$E1 + data[[i]]$E2 + data[[i]]$E3 +
      data[[i]]$E4 + data[[i]]$E5 + data[[i]]$E6
  
  max.time<-data[[1]]$cum.time[max(which(data[[1]]$I>0))] #maximum time in first simulation
  # max.y<-max(data[[1]]$C)       #find max total confirmed cases for plotting range
  # Changing this to max of C, I + Iu, or E to expand y range and capture all information
  if (is.na(max.y)) max.y <- max(c(max(data[[1]]$C), max(data[[1]]$I + data[[1]]$Iu), max(data[[1]]$E)))
  
  # calculate means
  m1 <- m2 <- m3 <- m4 <- m5 <- matrix(nrow=length(data[[1]]$I), ncol=nsims)
  for(i in 1:nsims){
    m1[,i] <- data[[i]]$E
    m2[,i] <- data[[i]]$I+data[[i]]$Iu
    # m3[,i] <- data[[i]]$Iu
    m4[,i] <- data[[i]]$H
    m5[,i] <- data[[i]]$C
  }
  E.mean <- rowMeans(m1)
  I.mean <- rowMeans(m2)
  # Iu.mean <- rowMeans(m3)
  H.mean <- rowMeans(m4)
  C.mean <- rowMeans(m5)
  
  # colors
  col.E.ci <- rgb(0,1,0,.25)
  col.I.ci <- rgb(1,0,0,.25)
  Iu.col <- rgb(0.5, 0.5, 0, 0.25)
  col.nowcast.ci <- rgb(0,0,1,.25)
  col.cases.ci <- rgb(0,0,0,.25)
  col.E <- rgb(0,1,0,1)
  col.I <- rgb(1,0,0,1)
  Iu.mean.col <- rgb(0.5,0.5,0,1)
  col.nowcast <- rgb(0,0,1,1)
  col.cases <- rgb(0,0,0,1)
  
  #set up plot
  plot(I~cum.time,data=data[[1]],xlab='',ylab='Cases',col=1,
       xlim=c(0,max.time),ylim=c(1,max.y), type='n', lty=1, log=log,
       axes=FALSE, main=title, cex.main=1) # set up plot
  
  # add data to plot
  # day <- georgia$date - start
  # lines(day, cumsum(georgia$cases), type='h', col=col.cases, lwd=3, lend='butt' )
  # Switch to ACC real data (acc_df)
  day <- accdata.date - attr(data, "start_date")
  lines(day, accdata.cases, type = 'h', col = col.cases, 
        lwd = 3, lend = 'butt')
  
  # plot spaghetti
  lines(E~cum.time,data=data[[1]], col=col.E.ci, lty=1)
  lines(I+Iu~cum.time,data=data[[1]], col=col.I.ci, lty=1)
  # lines(Iu~cum.time,data=data[[1]], col=Iu.col, lty=1)
  lines(H~cum.time,data=data[[1]], col=col.nowcast.ci, lty=1)
  lines(C~cum.time,data=data[[1]], col=col.cases.ci, lty=1, lwd=1)
  

  axis(1, at=seq(0,max.time,5), labels=format(attr(data, "start_date")+seq(0,max.time,5), format= '%b %d'))
  axis(2)
  box()
  
  if(nsims > 1){
    for (k in 2:min(100,nsims)) {              #add multiple epidemics to plot
      lines(E~cum.time, data=data[[k]], col=col.E.ci, type='l', lty=1)
      lines(I+Iu~cum.time, data=data[[k]], col=col.I.ci, type='l', lty=1)
      #   lines(Iu~cum.time, data=data[[k]], col=Iu.col, type='l', lty=1)
      lines(H~cum.time, data=data[[k]], col=col.nowcast.ci, type='l', lty=1)
      lines(C~cum.time, data=data[[k]], col=col.cases.ci, type='l', lty=1, lwd=1)
    }
    
    # plot means
    lines(E.mean~cum.time, data=data[[k]], col=col.E, lty=1)
    lines(I.mean~cum.time, data=data[[k]], col=col.I, lty=1)  
    #  lines(Iu.mean~cum.time, data=data[[k]], col=Iu.mean.col, lty=1)
    lines(H.mean~cum.time, data=data[[k]], col=col.nowcast, lty=1)
    lines(C.mean~cum.time, data=data[[k]], col=col.cases, lty=1)
  } 
  
  legend('topleft', lty=c(1,1,1,1,1,1), lwd=c(1,1,1,1,3,3), bty='n', cex=0.75,
         col=c(col.E, col.I, col.nowcast, col.cases, 'black'),
         legend=c('Latent cases in the community', 'Infectious cases in the community', 'Isolated', 
                  'Cumulative reported cases (Model)', 'Cumulative reported cases (Data)'))
}

plot.model.acc <- function(data, accdata.date, accdata.cases, log='y', title='',
                           max.y = NA, meanonly = FALSE, trim.days = 0,
                           include.lines = c("C", "Iso", "Inf", "L")) {
  # The function `plot.model` provides automated visualization of model simulations
  # ACC specific in terms of real data
  # process data
  nsims <- length(data)
  
  for(i in 1:nsims) data[[i]]$I <- data[[i]]$I1 + data[[i]]$I2 + data[[i]]$I3 +
      data[[i]]$I4
  for(i in 1:nsims) data[[i]]$Iu <- data[[i]]$Iu1 + data[[i]]$Iu2 + data[[i]]$Iu3 +
      data[[i]]$Iu4
  for(i in 1:nsims) data[[i]]$E <- data[[i]]$E1 + data[[i]]$E2 + data[[i]]$E3 +
      data[[i]]$E4 + data[[i]]$E5 + data[[i]]$E6
  
  max.time <- data[[1]]$cum.time[max(which(data[[1]]$I > 0))] #maximum time in first simulation
  # max.y<-max(data[[1]]$C)       #find max total confirmed cases for plotting range
  # Changing this to max of C, I + Iu, or E to expand y range and capture all information
  if (is.na(max.y)) max.y <- max(c(max(data[[1]]$C), 
                                   max(data[[1]]$I + data[[1]]$Iu), 
                                   max(data[[1]]$E)))
  
  # calculate means
  m1 <- m2 <- m3 <- m4 <- m5 <- matrix(nrow=length(data[[1]]$I), ncol=nsims)
  for(i in 1:nsims){
    m1[,i] <- data[[i]]$E
    m2[,i] <- data[[i]]$I+data[[i]]$Iu
    # m3[,i] <- data[[i]]$Iu
    m4[,i] <- data[[i]]$H
    m5[,i] <- data[[i]]$C
  }
  E.mean <- rowMeans(m1)
  I.mean <- rowMeans(m2)
  # Iu.mean <- rowMeans(m3)
  H.mean <- rowMeans(m4)
  C.mean <- rowMeans(m5)
  
  # colors
  col.E.ci <- rgb(0,1,0,.25)
  col.I.ci <- rgb(0,0,1,.25)           
  Iu.col <- rgb(0.5, 0.5, 0, 0.25)
  col.nowcast.ci <- rgb(1,0,0,.25)
  col.cases.ci <- rgb(0,0,0,.25)
  col.E <- rgb(0,1,0,1)
  col.I <- rgb(0,0,1,1) 
  Iu.mean.col <- rgb(0.5,0.5,0,1)
  col.nowcast <- rgb(1,0,0,1)
  col.cases <- rgb(0,0,0,1)
  
  #set up plot
  plt <- ggplot() +
    labs(x = "",
         y = "Cases",
         title = title)
  # plot(I~cum.time,data=data[[1]],xlab='',ylab='Cases',col=1,
  #      xlim=c(0,max.time),ylim=c(1,max.y), type='n', lty=1, log=log,
  #      axes=FALSE, main=title, cex.main=1) # set up plot
  
  # add data to plot
  # day <- georgia$date - start
  # lines(day, cumsum(georgia$cases), type='h', col=col.cases, lwd=3, lend='butt' )
  # Switch to ACC real data (acc_df)
  day <- accdata.date - attr(data, "start_date")

  # plt <- plt +
  #   geom_col(mapping = aes(accdata.date, accdata.cases), width = 0.5)
  plt <- plt +
    geom_col(mapping = aes(seq.int(from = 1, to = length(accdata.cases), 
                                   by = 1), accdata.cases),
             width = 0.5)
  # lines(day, accdata.cases, type = 'h', col = col.cases, 
  #       lwd = 3, lend = 'butt')

  # plot spaghetti
  if (!meanonly) {
    # include.lines = c("C", "Iso", "Inf", "L")
    if ("L" %in% include.lines) plt <- plt +
        geom_line(data = data[[1]], mapping = aes(cum.time, E),
                  color = col.E.ci)
    if ("Inf" %in% include.lines) plt <- plt +
        geom_line(data = data[[1]], mapping = aes(cum.time, I + Iu),
                  color = col.I.ci)
    if ("Iso" %in% include.lines) plt <- plt +
        geom_line(data = data[[1]], mapping = aes(cum.time, H),
                  color = col.nowcast.ci)
    if ("C" %in% include.lines) plt <- plt +
        geom_line(data = data[[1]], mapping = aes(cum.time, C),
                  color = col.cases.ci)
  }
  

  # lines(E~cum.time,data=data[[1]], col=col.E.ci, lty=1)
  # lines(I+Iu~cum.time,data=data[[1]], col=col.I.ci, lty=1)
  # # lines(Iu~cum.time,data=data[[1]], col=Iu.col, lty=1)
  # lines(H~cum.time,data=data[[1]], col=col.nowcast.ci, lty=1)
  # lines(C~cum.time,data=data[[1]], col=col.cases.ci, lty=1, lwd=1)

  plt <- plt +
    theme_classic() +
    scale_x_continuous(breaks = seq.int(0, max.time - trim.days, 5),
                       limits = c(0, max.time - trim.days),
                       labels = format(attr(data, "start_date") +
                                         seq.int(0, max.time - trim.days, 5),
                                       format = '%b %d')) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_continuous(trans = "log2", limits = c(1, 1e5),
                       breaks = c(1e1, 1e2, 1e3, 1e4, 1e5))

  # axis(1, at=seq(0,max.time,5), 
  #      labels=format(attr(data, "start_date")+seq(0,max.time,5), 
  #                    format= '%b %d'))
  # axis(2)
  # box()
  
  if (!meanonly) {
    if (nsims > 1) {
      for (k in 2:min(100,nsims)) {              #add multiple epidemics to plot
        
        if ("L" %in% include.lines) plt <- plt +
          geom_line(data = data[[k]], mapping = aes(cum.time, E),
                    color = col.E.ci)
        if ("Inf" %in% include.lines) plt <- plt +
          geom_line(data = data[[k]], mapping = aes(cum.time, I + Iu),
                    color = col.I.ci)
        if ("Iso" %in% include.lines) plt <- plt +
          geom_line(data = data[[k]], mapping = aes(cum.time, H),
                    color = col.nowcast.ci)
        if ("C" %in% include.lines) plt <- plt +
          geom_line(data = data[[k]], mapping = aes(cum.time, C),
                    color = col.cases.ci)
        
        # lines(E~cum.time, data=data[[k]], col=col.E.ci, type='l', lty=1)
        # lines(I+Iu~cum.time, data=data[[k]], col=col.I.ci, type='l', lty=1)
        # #   lines(Iu~cum.time, data=data[[k]], col=Iu.col, type='l', lty=1)
        # lines(H~cum.time, data=data[[k]], col=col.nowcast.ci, type='l', lty=1)
        # lines(C~cum.time, data=data[[k]], col=col.cases.ci, type='l', lty=1, lwd=1)
      }
      
      
    }
  }
  
  # plot means
  if ("L" %in% include.lines) plt <- plt +
    geom_line(data = data[[1]], 
              mapping = aes(cum.time, E.mean, color = "latent"))
  if ("Inf" %in% include.lines) plt <- plt +
    geom_line(data = data[[1]], 
              mapping = aes(cum.time, I.mean, color = "isolated"))
  if ("Iso" %in% include.lines) plt <- plt +
    geom_line(data = data[[1]], 
              mapping = aes(cum.time, H.mean, color = "infectious"))
  if ("C" %in% include.lines) plt <- plt +
    geom_line(data = data[[1]], 
              mapping = aes(cum.time, C.mean, color = "cases"))
  # lines(E.mean~cum.time, data=data[[k]], col=col.E, lty=1)
  # lines(I.mean~cum.time, data=data[[k]], col=col.I, lty=1)  
  # #  lines(Iu.mean~cum.time, data=data[[k]], col=Iu.mean.col, lty=1)
  # lines(H.mean~cum.time, data=data[[k]], col=col.nowcast, lty=1)
  # lines(C.mean~cum.time, data=data[[k]], col=col.cases, lty=1)
  
  values.vec <- c()
  labels.vec <- c()
  if ("L" %in% include.lines) {
    values.vec <- c(values.vec, "latent" = col.E)
    labels.vec <- c(labels.vec, "Latent cases in the community")
  }
  if ("Inf" %in% include.lines) {
    values.vec <- c(values.vec, "isolated" = col.nowcast)
    labels.vec <- c(labels.vec, "Isolated")
  }
  if ("Iso" %in% include.lines) {
    values.vec <- c(values.vec,"infectious" = col.I )
    labels.vec <- c(labels.vec, "Infectious cases in the community")
  }
  if ("C" %in% include.lines) {
    values.vec <- c(values.vec, "cases" = col.cases)
    labels.vec <- c(labels.vec, "Cumulative reported cases")
  }
  labels.vec <- rev(labels.vec)
  
  nrow.val = ifelse(length(include.lines) > 2, 2, 1)
  
  plt <- plt +
    scale_color_manual(name = "",
                       values = values.vec,
                       labels = labels.vec) +
    theme(legend.position = "bottom", legend.justification = "left",
          legend.spacing.y = unit(0.1, "cm"),
          legend.key = element_rect(color = "transparent"),
          plot.title = element_text(size = 10),
          legend.text = element_text(margin = margin(t = 0, unit = "pt"))) +
    guides(color = guide_legend(nrow = nrow.val, byrow = TRUE))

 return(plt)
  # legend('topleft', lty=c(1,1,1,1,1,1), lwd=c(1,1,1,1,3,3), bty='n', cex=0.75,
  #        col=c(col.E, col.I, col.nowcast, col.cases, 'black'),
  #        legend=c('Latent cases in the community', 'Infectious cases in the community', 'Isolated', 
  #                 'Cumulative reported cases (Model)', 'Cumulative reported cases (Data)'))
}

gamma <- function(z = 12, b=0.143, a0=1/1.5, t){
  # piecewise function
  # default parameters z = 12, b=1/7, a0=1/1.5
  #    z: time at start of intervention (notionally March 12)
  #    b: intercept (positive)
  #    a0: post intervention isolation ratae
  #    t: time in the model
  
  gamma <- ifelse(t<=z, gamma <- b, gamma <- a0)
  return(gamma)
}

eta <- function(t, w=12) ifelse(t<=w,1/3,1/3)

q <- function(t, w=12, q0=1, q1=1) ifelse(t<=w,q0,q1)

beta <- function(t, w=12, beta0=0.6584, beta.factor=2) ifelse(t<=w,beta0,beta0/beta.factor)

return_maxvals <- function(data) {
  
  nsims <- length(data)
  
  for(i in 1:nsims) data[[i]]$I <- data[[i]]$I1 + data[[i]]$I2 + data[[i]]$I3 +
      data[[i]]$I4
  for(i in 1:nsims) data[[i]]$Iu <- data[[i]]$Iu1 + data[[i]]$Iu2 + data[[i]]$Iu3 +
      data[[i]]$Iu4
  for(i in 1:nsims) data[[i]]$E <- data[[i]]$E1 + data[[i]]$E2 + data[[i]]$E3 +
      data[[i]]$E4 + data[[i]]$E5 + data[[i]]$E6
  
  max.time<-data[[1]]$cum.time[max(which(data[[1]]$I>0))] #maximum time in first simulation
  # max.y<-max(data[[1]]$C)       #find max total confirmed cases for plotting range
  # Changing this to max of C, I + Iu, or E to expand y range and capture all information
  max.y <- max(c(max(data[[1]]$C), max(data[[1]]$I + data[[1]]$Iu), max(data[[1]]$E)))
  
  return(list(max.time = max.time,
              max.y = max.y))
}

### Modelling Healthcare -------------------------------------------------------
model_hospitalizations <- function(data) {

  nsims <- length(data)
  
  # Need to pass the results of the evaluate.model function (MOD)
  # X number of simulations for a specific set of parameters and starting values  
  for(i in 1:nsims) data[[i]]$I <- data[[i]]$I1 + data[[i]]$I2 + data[[i]]$I3 +
      data[[i]]$I4
  for(i in 1:nsims) data[[i]]$Iu <- data[[i]]$Iu1 + data[[i]]$Iu2 + data[[i]]$Iu3 +
      data[[i]]$Iu4
  for(i in 1:nsims) data[[i]]$E <- data[[i]]$E1 + data[[i]]$E2 + data[[i]]$E3 +
      data[[i]]$E4 + data[[i]]$E5 + data[[i]]$E6
  
  #maximum time in first simulation
  max.time<-data[[1]]$cum.time[max(which(data[[1]]$I>0))] 
  #find max total confirmed cases for plotting range
  # max.y<-max(data[[1]]$C)
  # Changing this to max of C, I + Iu, or E to expand y range and capture all information
  max.y <- max(c(max(data[[1]]$C), max(data[[1]]$I + data[[1]]$Iu), 
                 max(data[[1]]$E)))
  
  # calculate means
  # m1 <- m2 <- m3 <- m4 <- m5 <- matrix(nrow = length(data[[1]]$I), ncol = nsims)
  m1 <- m2 <- m4 <- m5 <- matrix(nrow = length(data[[1]]$I), ncol = nsims)
  for(i in 1:nsims){
    m1[, i] <- data[[i]]$E
    m2[, i] <- data[[i]]$I + data[[i]]$Iu
    # m3[, i] <- data[[i]]$Iu
    m4[, i] <- data[[i]]$H
    m5[, i] <- data[[i]]$C
  }
  E.mean <- rowMeans(m1)
  I.mean <- rowMeans(m2)
  # Iu.mean <- rowMeans(m3)
  H.mean <- rowMeans(m4)
  C.mean <- rowMeans(m5)

  # read in healthcare parameters file
  hc_params <- read_csv("Data/hc_params.csv")
  hc_params <- setNames(split(hc_params$value, seq(nrow(hc_params))), 
                        hc_params$param)
  # create variables from list of parameters
  # this is done so as to not have to edit as much of Andreas' code
  for (i in 1:length(hc_params)) {
    assign(paste0(names(hc_params)[i]), hc_params[[i]])
  }
  
  Na <- Ntot - Nc - Ne #everyone between 18 and 65 (adults)
  C_prop <- Nc / Ntot
  A_prop <- Na / Ntot
  E_prop <- Ne / Ntot
  VE_prop <- Nve / Ntot
  
  # res = list() #save results as list
  # for (n1 in 1:length(data)) #looping over all scenarios
  # {
    # x = data[[n1]]
    x <- data
    res2 <- list() #results from each stochastic replicate
    
    #loop over each stochastic replicate simulation for a given scenario
    for (n2 in 1:length(x)) 
    {
      y <- x[[n2]]

      #daily data
      report.times <- seq(1, (length(y$cum.time)), by = (1 / attr(data, "dt"))) 
      #use notified cases as basis for hospitalizations
      #this has a few day time lag between a person being diagnosed
      Ctotdaily = y$C[report.times] #total number of cases
      Cnewdaily = diff(Ctotdaily) #daily number of new cases

      # new hospitalizations
      # assuming specific proportions of children/adults/elderly and 
      # associated risks   
      Hosp_new_low = Cnewdaily * (C_prop * C_hosp_low + A_prop * A_hosp_low + 
                                    E_prop * E_hosp_low + VE_prop * VE_hosp_low)  
      Hosp_new_high = Cnewdaily * (C_prop * C_hosp_high + A_prop * A_hosp_high + 
                                     E_prop * E_hosp_high + 
                                     VE_prop * VE_hosp_high) 
      
      # total hospitalization, is the cumulative of the last hosp_time days of 
      # new hospitalizations
      Hosp_tot_low = rep(0, length(Hosp_new_low))
      Hosp_tot_high = Hosp_tot_low
      for (n3 in 1:length(Hosp_new_low))
      {
        Hosp_tot_low[n3] = sum(Hosp_new_low[max(1, n3 - hosp_time_low):n3])
        Hosp_tot_high[n3] = sum(Hosp_new_high[max(1, n3 - hosp_time_high):n3]) 
      }
      
      # new critical cases
      # assuming specific proportions of children/adults/elderly and associated 
      #   critical risks   
      Crit_new_low = Cnewdaily * (C_prop * C_hosp_low * C_crit_low + 
                                    A_prop * A_hosp_low * A_crit_low + 
                                    E_prop * E_hosp_low * E_crit_low + 
                                    VE_prop * VE_hosp_low * VE_crit_low)  
      Crit_new_high = Cnewdaily * (C_prop * C_hosp_high * C_crit_high + 
                                     A_prop * A_hosp_high * A_crit_high + 
                                     E_prop * E_hosp_high * E_crit_high + 
                                     VE_prop * VE_hosp_high * VE_crit_high)
      
      # total critical, is the cumulative of the last crit_time days of new 
      #   critical
      Crit_tot_low = rep(0, length(Crit_new_low))
      Crit_tot_high = Crit_tot_low
      for (n3 in 1:length(Crit_new_low))
      {
        Crit_tot_low[n3] = sum(Crit_new_low[max(1, n3 - crit_time_low):n3])
        Crit_tot_high[n3] = sum(Crit_new_high[max(1, n3 - crit_time_high):n3]) 
      }
      
      #new deaths - should be lagged
      Dead_new_low = Cnewdaily * (C_prop * C_death_low + A_prop * A_death_low + 
                                    E_prop * E_death_low + 
                                    VE_prop * VE_death_low)  
      Dead_new_high = Cnewdaily * (C_prop * C_death_high + 
                                     A_prop * A_death_high + 
                                     E_prop * E_death_high + 
                                     VE_prop * VE_death_high) 
      
      # total hospitalization, is the cumulative of the last hosp_time days of 
      #   new hospitalizations
      Dead_tot_low = cumsum(Dead_new_low)
      Dead_tot_high = cumsum(Dead_new_high)
      
      #save result for each stochastic simulations    
      dat = round(data.frame(Case_new = Cnewdaily, Case_tot = Ctotdaily[-1], 
                             Hosp_new_low, Hosp_new_high, Hosp_tot_low, 
                             Hosp_tot_high, Crit_new_low, Crit_new_high, 
                             Crit_tot_low, Crit_tot_high, Dead_new_low, 
                             Dead_new_high, Dead_tot_low, Dead_tot_high))
      
      res2[[n2]] = dat    
      
    } #end loop over stochastic replicates
    # save results
    # res[[n1]] = res2 
  # } #end loop over scenarios

    attr(res2, "nsims") <- attr(data, "nsims")
    attr(res2, "start_date") <- attr(data, "start_date")
    attr(res2, "ndays") <- attr(data, "ndays")
    
    return(res2)
}

summarise_model_hospitalizations <- function(model_res) {

  # read in healthcare parameters file
  hc_params <- read_csv("Data/hc_params.csv")
  hc_params <- setNames(split(hc_params$value, seq(nrow(hc_params))), 
                        hc_params$param)
  # create variables from list of parameters
  for (i in 1:length(hc_params)) {
    assign(paste0(names(hc_params)[i]), hc_params[[i]])
  }
  
  # dates for all. Assume hospitalizations are t_delay days delayed from case 
  #   notifications, critical is same as hospital
  # deaths should probably be lagged further, are currently not
  
  # Dates = seq(from = attr(model_res, "start_date"), 
  #             to = (attr(model_res, "start_date") + 
  #                     attr(model_res, "ndays") -1) + death_delay, "days" )
  Dates = seq(from = attr(model_res, "start_date"), 
              to = attr(model_res, "start_date") + attr(model_res, "ndays") +
                death_delay - 1, 
              "days" )
  dat = list()
  # for (n1 in 1:length(sims)) #looping over all scenarios
  # {
    # x = res[[n1]] #pull out each scenario
    x <- model_res
    for (n2 in 1:length(x)) #loop over all realizations, compute means
    {
      if (n2 == 1) xt = x[[n2]] 
      else xt = xt + x[[n2]]
    }
    xt = round(xt / length(x))
    # run over each outcome column in xt, add to data frame time-shifted 
    # to account for delays
    
    df = array(0, dim = c(length(Dates), ncol(xt))) #empty data frame
    for (n2 in 1:ncol(xt))
    {
      if (n2 < 3) #cases, no time lag
      { 
        df[1:nrow(xt), n2] = xt[, n2]
      }
      if (n2 > 2 && n2 < 11) #hosp and crit, 7 day time lag
      { 
        df[(1 + hosp_delay):(nrow(xt) + hosp_delay), n2] = xt[, n2]
      }
      if (n2>10 ) #death, 14 day time lag
      { 
        df[(1+death_delay):(nrow(xt)+death_delay),n2] = xt[,n2]
      }
    }
    colnames(df) = colnames(xt)
    
    # dat[[n1]] = data.frame(Dates, df)
    dat <- data.frame(Dates, df)
    
    attr(data, "nsims") <- attr(model_res, "nsims")
    attr(data, "start_date") <- attr(model_res, "start_date")
    attr(data, "ndays") <- attr(model_res, "ndays")
    
    return(dat)
  # } #end loop over scenarios
  #write computed results to file
  # saveRDS(dat,'healthcareresults.rds')
}

# take the total column and use row differences to get a new cases column
# use the new cases column to create a delayed exit hospital column
# combine new cases and exit hospital column to estiamte numbers throughout
# function created by Justin
hospital_capacity <- function(res_sum) {
  

  # read in healthcare parameters file
  hc_params <- read_csv("Data/hc_params.csv")
  hc_params <- setNames(split(hc_params$value, seq(nrow(hc_params))), 
                        hc_params$param)
  # create variables from list of parameters
  for (i in 1:length(hc_params)) {
    assign(paste0(names(hc_params)[i]), hc_params[[i]])
  }
  
  df <- res_sum
  df$Hosp_case_low <- c(df$Hosp_tot_low[1], diff(df$Hosp_tot_low, 1))
  df$Hosp_case_high <- c(df$Hosp_tot_high[1], diff(df$Hosp_tot_high, 1))
  # df$Crit_case_low <- c(df$Crit_tot_low[1], diff(df$Crit_tot_low, 1))
  # df$Crit_case_high <- c(df$Crit_tot_high[1], diff(df$Crit_tot_high, 1))
  
  # hosp_time_avg <- round((hosp_time_low + hosp_time_high) / 2)
  hosp_time_avg <- hosp_time_low
  # use hosp_time_avg
  # limit to hospitalizations for now
  df$Hosp_exit_low <- c(rep(0, hosp_time_avg), 
                        df$Hosp_case_low[1:(length(df$Hosp_case_low) - 
                                              hosp_time_avg)])
  df$Hosp_exit_high <- c(rep(0, hosp_time_avg), 
                         df$Hosp_case_high[1:(length(df$Hosp_case_high) - 
                                                hosp_time_avg)])
  
  # new hospital capacity related variable that adds new cases and allows
  # others to leave along the way
  # Try it as a loop
  df$Hosp_capacity_low <- NA
  df$Hosp_capacity_high <- NA
  df$Hosp_capacity_low[1] <- df$Hosp_case_low[1]
  df$Hosp_capacity_high[1] <- df$Hosp_case_high[1]
  for (i in 2:nrow(df)) {
    df$Hosp_capacity_low[i] <- df$Hosp_capacity_low[i - 1] +
      df$Hosp_case_low[i] - df$Hosp_exit_low[i]
    df$Hosp_capacity_high[i] <- df$Hosp_capacity_high[i - 1] +
      df$Hosp_case_high[i] - df$Hosp_exit_high[i]
  }
  df %<>% filter(Case_tot > 0)
  return(df)
}


plot_model_hc <- function(res_sum) {
  
  res_sum %<>% filter(Case_tot > 0)
  plotdat <- res_sum %>% pivot_longer(-Dates, names_to = "Setting", 
                                      values_to = "Numbers" ) 
  plotdat %<>% mutate(Type = factor(stringr::str_sub(plotdat$Setting, 1, 8),  
                                    levels = c("Case_new", "Case_tot",
                                               "Hosp_new", "Hosp_tot",
                                               "Crit_new", "Crit_tot",
                                               "Dead_new", "Dead_tot") ) )  
  plotdat %<>% mutate(H_or_L = as.factor(stringr::str_sub(plotdat$Setting, 10)))
  pl <- plotdat %>% ggplot() + 
    geom_line(aes(x = Dates, y = Numbers, color = H_or_L)) + 
    facet_wrap(~Type, ncol = 2, scales = "free") +
    theme_bw() +
    theme(legend.position = "none")
  #pl <- ggplotly(pl)
  return(pl)
}

plot_hospitalizations <- function(res_sum, title = "", type = "cum",
                                  hosp_file = NA) {
  
  # read in up to date hospitalizations file
  if (is.na(hosp_file)) parmc_df <- read_format_hosp("Data/parmc_hospitalizations.csv")
  else parmc_df <- read_format_hosp(hosp_file)

  # Only plot two weeks into the future
  parmc_df %<>% filter(AdmitDates <= (Sys.Date() + 21))
  res_sum %<>% filter(Dates <= (Sys.Date() + 21))
  
  # create figure to compare model and actual hospitalizations
  if (type == "cum") {
    # ggplot() +
    #   geom_bar(mapping = aes(x = AdmitDates, y = Number_cum),
    #            data = parmc_df, stat = "identity") +
    #   geom_line(mapping = aes(x = Dates, y = Hosp_tot_high),
    #             data = res_sum) +
    #   labs(x = "Dates", y = "Total number of hospitalizations",
    #        title = title) +
    #   theme_classic()
    
    ggplot() +
      geom_bar(mapping = aes(x = AdmitDates, y = Number_cum),
               data = parmc_df, stat = "identity") +
      geom_line(mapping = aes(x = Dates, y = cumsum(Hosp_new_high), color = "red"),
                data = res_sum) +
      geom_line(mapping = aes(x = Dates, y = cumsum(Hosp_new_low), color = "green"),
                data = res_sum) +
      labs(x = "Dates", y = "Total number of hospitalizations",
           title = title) +
      scale_color_discrete(name = "Model Bounds", labels = c("Lower", "Upper")) +
      theme_classic()
      
    
  } else if (type == "capacity") {
    # ggplot() +
    #   geom_bar(mapping = aes(x = AdmitDates, y = HospNum),
    #            data = parmc_df, stat = "identity") +
    #   geom_line(mapping = aes(x = Dates, y = Hosp_capacity_high),
    #             data = res_sum) +
    #   labs(x = "Dates", y = "Current number of hospitalized",
    #        title = title) +
    #   theme_classic()
    
    ggplot() +
      geom_bar(mapping = aes(x = AdmitDates, y = HospNum),
               data = parmc_df, stat = "identity") +
      geom_line(mapping = aes(x = Dates, y = Hosp_tot_high, color = "red"),
                data = res_sum) +
      geom_line(mapping = aes(x = Dates, y = Hosp_tot_low, color = "green"),
                data = res_sum) +
      labs(x = "Dates", y = "Current number of hospitalized",
           title = title) +
      scale_color_discrete(name = "Model Bounds", labels = c("Lower", "Upper")) +
      theme_classic()
    
  } else if (type == "pct") {
    res_sum %<>% mutate(hosp_pct_high = cumsum(Hosp_new_high) / Case_tot,
                        hosp_pct_low = cumsum(Hosp_new_low) / Case_tot)
    ggplot(data = res_sum) +
      geom_line(mapping = aes(x = Dates, y = hosp_pct_high, color = "red")) +
      geom_line(mapping = aes(x = Dates, y = hosp_pct_low, color = "green")) +
      labs(x = "Dates", y = "Percent of Cases Hospitalized",
           title = title) +
      scale_color_discrete(name = "Model Bounds", labels = c("Lower", "Upper")) +
      theme_classic()
    
  }
  
}

read_format_hosp <- function(hosp_file = NA) {
  
  if (is.na(hosp_file)) df <- read_csv("Data/parmc_hospitalizations.csv")
  else df <- read_csv(hosp_file)
  # create file with cumulative cases by date
  # and number in hospital by date
  df %<>% mutate(Admit = mdy(Admit),
                 Discharge = mdy(Discharge))
  date_span <- c(min(df$Admit), max(df$Admit))
  AdmitDates <- seq(from = date_span[1], to = date_span[2], by = 1)
  
  tmp <- df %>%
    group_by(Admit) %>%
    dplyr::summarise(Number = n())
  
  out_df <- data.frame(AdmitDates = AdmitDates)
  out_df %<>% full_join(tmp, by = c("AdmitDates" = "Admit")) %>%
    mutate(Number = ifelse(is.na(Number), 0, Number))
  
  out_df %<>% full_join(df %>%
                          group_by(Discharge) %>%
                          dplyr::summarise(DischNumber = n()),
                        by = c("AdmitDates" = "Discharge")) %>%
    mutate(DischNumber = ifelse(is.na(DischNumber), 0, DischNumber))
  
  out_df %<>% mutate(Number_cum = cumsum(Number),
                     DischNumber_cum = cumsum(DischNumber))
  
  out_df %<>% mutate(HospNum = Number_cum - DischNumber_cum) %>%
    filter(!is.na(AdmitDates))
  
  return(out_df)
}


### Read and Format Athens Cases Data ------------------------------------------
dailyCases <- read_csv("/Users/ishaandave/Box/Random Help Items/COVID19 Git/COVID19_Athens_Model/Colquitt_and_surrounding/Data/SW_primSecNewCasesDaily.csv")

dailyCases$secondary <- rowSums(dailyCases[,2:15])
# NOTE:


dailyCases2 <- dailyCases[1:which(dailyCases$date == as.character(Sys.Date()-1)), ]
dailyCases2$secondary_cum <- cumsum(dailyCases2$secondary)



scenarios <- read.csv("/Users/ishaandave/Box/Random Help Items/COVID19 Git/COVID19_Athens_Model/Colquitt_and_surrounding/Data/SW scenarios.csv")

scenarios[8, 15:24] = scenarios[7, 15:24] # forgot to update the E's and I's for social distancing 
                                          # This code takes those values from the baseline 
                                          # with no intervention (row 7) since we are supposed 
                                          # to have the same number of starting cases (55)
                                          # and NOT!! 82 like it says in the actual scenario datasheet.


scenarios[9, 15:ncol(scenarios)] = scenarios[5, 15:ncol(scenarios)]
scenarios[9, 1:14] = scenarios[7, 1:14]
# Only the first 8 are currently setup
scenarios <- scenarios[c(1:9), ]
# move columns 11 and 12 to the end
scenarios <- scenarios[, c(1:10, 13:31, 11, 12)]


### Baseline, natural epidemic -- no interventions

scen_row <- 7

# If nationally was 3/12/20 then this is prior to ACC outbreak so z = 0
gamma <- function(z = scenarios[scen_row, "z"], b=scenarios[scen_row, "b"], a0=scenarios[scen_row, "a0"], t){
  # piecewise function
  # default parameters z = 12, b=1/7, a0=1/1.5
  #    z: time at start of intervention (notionally March 12)
  #    b: intercept (positive)
  #    a0: post intervention isolation ratae
  #    t: time in the model
  
  gamma <- ifelse(t<=z, gamma <- b, gamma <- a0)
  return(gamma)
}
eta <- function(t, w = scenarios[scen_row, "w"]) ifelse(t<=w, 1/3, 1/3)
q <- function(t, w = scenarios[scen_row, "w"], q0=scenarios[scen_row, "q0"], q1=scenarios[scen_row, "q1"]) ifelse(t<=w, q0, q1)
beta <- function(t, w = scenarios[scen_row, "w"], beta0=scenarios[scen_row, "beta0"], beta.factor=2) {
  ifelse(t<=w, beta0, beta0 / beta.factor)
} 

start = as.Date("2020-03-14")
s <- scenarios[,3:31]
i <- scen_row
outBaselineInt <- evaluate.model(params=list(beta0=s[i,1], sigma=s[i,2], z=s[i,3], b=s[i,4], a0=s[i,5], w=s[i,6], presymptomatic=s[i,8], c=s[i,7], dt=0.05),
                       init = list(S=s[i,10], E1=s[i,11], E2=s[i,12], E3=s[i,13], E4=s[i,14], E5=s[i,15], E6=s[i,16],
                                   I1 = s[i,17], I2 = s[i,18], I3 = s[i,19], I4 = s[i,20], Iu1=s[i,21], Iu2=s[i,22], Iu3=s[i,23], Iu4=s[i,24],
                                   H=s[i,25], Ru=s[i,26], C=s[i,27]),
                       nsims=15, nstep=NULL, start=start)



plot.model.acc(outBaselineInt, dailyCases2$date[1:which(dailyCases$date == Sys.Date()-1)], 
               dailyCases2$secondary_cum[1:which(dailyCases$date == Sys.Date()-1)],
               log='y', title='Natural Epidemic (No Social Distancing)')



### Social Distancing implemented -- early intervention  
## This model ssuming whole area put shelter-in-place order on March 21 (when Dougherty county did) 

scen_row <- 8

# If nationally was 3/12/20 then this is prior to ACC outbreak so z = 0
gamma <- function(z = 7, b=scenarios[scen_row, "b"], a0=scenarios[scen_row, "a0"], t){
  # piecewise function
  # default parameters z = 12, b=1/7, a0=1/1.5
  #    z: time at start of intervention (notionally March 12)
  #    b: intercept (positive)
  #    a0: post intervention isolation ratae
  #    t: time in the model
  
  gamma <- ifelse(t<=z, gamma <- b, gamma <- a0)
  return(gamma)
}
eta <- function(t, w = scenarios[scen_row, "w"]) ifelse(t<=w, 1/3, 1/3)
q <- function(t, w = scenarios[scen_row, "w"], q0=scenarios[scen_row, "q0"], q1=scenarios[scen_row, "q1"]) ifelse(t<=w, q0, q1)
beta <- function(t, w = scenarios[scen_row, "w"], beta0=scenarios[scen_row, "beta0"], beta.factor=2) {
  ifelse(t<=w, beta0, beta0 / beta.factor)
} 

s <- scenarios[,3:31]
i <- scen_row
outSDearly<- evaluate.model(params=list(beta0=s[i,1], sigma=s[i,2], z=7, b=s[i,4], a0=s[i,5], w=s[i,6], presymptomatic=s[i,8], c=s[i,7], dt=s[i,9]),
                       init = list(S=s[i,10], E1=s[i,11], E2=s[i,12], E3=s[i,13], E4=s[i,14], E5=s[i,15], E6=s[i,16],
                                   I1 = s[i,17], I2 = s[i,18], I3 = s[i,19], I4 = s[i,20], Iu1=s[i,21], Iu2=s[i,22], Iu3=s[i,23], Iu4=s[i,24],
                                   H=s[i,25], Ru=s[i,26], C=s[i,27]),
                       nsims=15, nstep=NULL, start=start)

plot.model.acc(outSDearly,  dailyCases$date[1:which(dailyCases$date == Sys.Date()-1)], 
               dailyCases2$secondary_cum[1:which(dailyCases$date == Sys.Date()-1)],
               log='y', title='Social Distancing 3/21 Intervention')





## Social Distancing Upper Bound (poor social distancing)
## Shelter in place order on March 21

scen_row <- 8

# Too stringent, earlier assumptions likely make more sense
# If nationally was 3/12/20 then this is prior to ACC outbreak so z = 0
gamma <- function(z = 7, b=scenarios[scen_row, "b"], a0=scenarios[scen_row, "a0"], t){
  # piecewise function
  # default parameters z = 12, b=1/7, a0=1/1.5
  #    z: time at start of intervention (notionally March 12)
  #    b: intercept (positive)
  #    a0: post intervention isolation ratae
  #    t: time in the model
  
  gamma <- ifelse(t<=z, gamma <- b, gamma <- a0)
  return(gamma)
}
eta <- function(t, w = scenarios[scen_row, "w"]) ifelse(t<=w, 1/3, 1/3)
q <- function(t, w = scenarios[scen_row, "w"], q0=scenarios[scen_row, "q0"], q1=scenarios[scen_row, "q1"]) ifelse(t<=w, q0, q1)
beta <- function(t, w = scenarios[scen_row, "w"], beta0=scenarios[scen_row, "beta0"], beta.factor=1.5) {
  ifelse(t<=w, beta0, beta0 / beta.factor)
} 

s <- scenarios[,3:31]
i <- scen_row
outSDearlyUpper <- evaluate.model(params=list(beta0=s[i,1], sigma=s[i,2], z=7, b=s[i,4], a0=s[i,5], w=s[i,6], presymptomatic=s[i,8], c=s[i,7], dt=s[i,9]),
                       init = list(S=s[i,10], E1=s[i,11], E2=s[i,12], E3=s[i,13], E4=s[i,14], E5=s[i,15], E6=s[i,16],
                                   I1 = s[i,17], I2 = s[i,18], I3 = s[i,19], I4 = s[i,20], Iu1=s[i,21], Iu2=s[i,22], Iu3=s[i,23], Iu4=s[i,24],
                                   H=s[i,25], Ru=s[i,26], C=s[i,27]),
                       nsims=15, nstep=NULL, start=start)

plot.model.acc(outSDearlyUpper, dailyCases$date[1:which(dailyCases$date == Sys.Date()-1)], 
               dailyCases2$secondary_cum[1:which(dailyCases$date == Sys.Date()-1)], 
               log='y', title='Social Distancing 3/21 (Upper Bound)')




















## Social Distancing implemented late
## Assumes all counties followed Governor Kemp's shelter in place order on 4/2

scen_row <- 8

# If nationally was 3/12/20 then this is prior to ACC outbreak so z = 0
gamma <- function(z = 19, b=scenarios[scen_row, "b"], a0=scenarios[scen_row, "a0"], t){
  # piecewise function
  # default parameters z = 12, b=1/7, a0=1/1.5
  #    z: time at start of intervention (notionally March 12)
  #    b: intercept (positive)
  #    a0: post intervention isolation ratae
  #    t: time in the model
  
  gamma <- ifelse(t<=z, gamma <- b, gamma <- a0)
  return(gamma)
}
eta <- function(t, w = scenarios[scen_row, "w"]) ifelse(t<=w, 1/3, 1/3)
q <- function(t, w = scenarios[scen_row, "w"], q0=scenarios[scen_row, "q0"], q1=scenarios[scen_row, "q1"]) ifelse(t<=w, q0, q1)
beta <- function(t, w = scenarios[scen_row, "w"], beta0=scenarios[scen_row, "beta0"], beta.factor=2) {
  ifelse(t<=w, beta0, beta0 / beta.factor)
} 

s <- scenarios[,3:31]
i <- scen_row
outSDlate<- evaluate.model(params=list(beta0=s[i,1], sigma=s[i,2], z=19, b=s[i,4], a0=s[i,5], w=s[i,6], presymptomatic=s[i,8], c=s[i,7], dt=s[i,9]),
                       init = list(S=s[i,10], E1=s[i,11], E2=s[i,12], E3=s[i,13], E4=s[i,14], E5=s[i,15], E6=s[i,16],
                                   I1 = s[i,17], I2 = s[i,18], I3 = s[i,19], I4 = s[i,20], Iu1=s[i,21], Iu2=s[i,22], Iu3=s[i,23], Iu4=s[i,24],
                                   H=s[i,25], Ru=s[i,26], C=s[i,27]),
                       nsims=15, nstep=NULL, start=start)

plot.model.acc(outSDlate,  dailyCases$date[1:which(dailyCases$date == Sys.Date()-1)], 
               dailyCases2$secondary_cum[1:which(dailyCases$date == Sys.Date()-1)],
               log='y', title='Social Distancing 4/2')



## Social Distancing Upper Bound (social distancing done poorly)
## Shelter in place on 4/2 (Kemp's date)
scen_row <- 8

# Too stringent, earlier assumptions likely make more sense
# If nationally was 3/12/20 then this is prior to ACC outbreak so z = 0
gamma <- function(z = 19, b=scenarios[scen_row, "b"], a0=scenarios[scen_row, "a0"], t){
  # piecewise function
  # default parameters z = 12, b=1/7, a0=1/1.5
  #    z: time at start of intervention (notionally March 12)
  #    b: intercept (positive)
  #    a0: post intervention isolation ratae
  #    t: time in the model
  
  gamma <- ifelse(t<=z, gamma <- b, gamma <- a0)
  return(gamma)
}
eta <- function(t, w = scenarios[scen_row, "w"]) ifelse(t<=w, 1/3, 1/3)
q <- function(t, w = scenarios[scen_row, "w"], q0=scenarios[scen_row, "q0"], q1=scenarios[scen_row, "q1"]) ifelse(t<=w, q0, q1)
beta <- function(t, w = scenarios[scen_row, "w"], beta0=scenarios[scen_row, "beta0"], beta.factor=1.5) {
  ifelse(t<=w, beta0, beta0 / beta.factor)
} 

s <- scenarios[,3:31]
i <- scen_row
outSDlateUpper <- evaluate.model(params=list(beta0=s[i,1], sigma=s[i,2], z=19, b=s[i,4], a0=s[i,5], w=s[i,6], presymptomatic=s[i,8], c=s[i,7], dt=s[i,9]),
                             init = list(S=s[i,10], E1=s[i,11], E2=s[i,12], E3=s[i,13], E4=s[i,14], E5=s[i,15], E6=s[i,16],
                                         I1 = s[i,17], I2 = s[i,18], I3 = s[i,19], I4 = s[i,20], Iu1=s[i,21], Iu2=s[i,22], Iu3=s[i,23], Iu4=s[i,24],
                                         H=s[i,25], Ru=s[i,26], C=s[i,27]),
                             nsims=15, nstep=NULL, start=start)

plot.model.acc(outSDlateUpper, dailyCases$date[1:which(dailyCases$date == Sys.Date()-1)], 
               dailyCases2$secondary_cum[1:which(dailyCases$date == Sys.Date()-1)], 
               log='y', title='Social Distancing 4/2 (Upper Bound)')

```

















